# Comprehensive Notes on CSRF Tokens and Protection

## Table of Contents

1. [Introduction to CSRF](#introduction-to-csrf)
2. [Impact of CSRF Attacks](#impact-of-csrf-attacks)
3. [How CSRF Works](#how-csrf-works)
4. [Constructing a CSRF Attack](#constructing-a-csrf-attack)
5. [Common Defense Mechanisms Against CSRF](#common-defense-mechanisms-against-csrf)
    - [1. CSRF Tokens](#1-csrf-tokens)
    - [2. SameSite Cookies](#2-samesite-cookies)
    - [3. Referer-Based Validation](#3-referer-based-validation)
6. [Storing CSRF Tokens](#storing-csrf-tokens)
    - [1. Cookies](#1-cookies)
    - [2. Hidden Form Fields](#2-hidden-form-fields)
    - [3. HTML Meta Tags](#3-html-meta-tags)
    - [4. JavaScript Variables](#4-javascript-variables)
    - [5. Local Storage](#5-local-storage)
    - [6. Session Storage](#6-session-storage)
    - [7. Data Attributes](#7-data-attributes)
    - [8. URL Parameters](#8-url-parameters)
7. [Sample Request/Response Cycles](#sample-requestresponse-cycles)
    - [1. Using Request Headers and Body Data](#1-using-request-headers-and-body-data)
    - [2. Other Common Storage Methods](#2-other-common-storage-methods)
8. [Best Practices for CSRF Token Management](#best-practices-for-csrf-token-management)
9. [Conclusion](#conclusion)
10. [Additional Resources](#additional-resources)

---

## Introduction to CSRF

**Cross-Site Request Forgery (CSRF)** is a security exploit where an attacker tricks a user into performing actions on a web application in which they're authenticated. Unlike Cross-Site Scripting (XSS), which exploits vulnerabilities in input validation, CSRF leverages the trust that a site has in a user's browser.

---

## Impact of CSRF Attacks

In a successful CSRF attack, the attacker can:

- Change the user's account details (e.g., email, password).
- Perform unauthorized transactions (e.g., funds transfer).
- Gain full control over the user's account.
- If the user has privileged roles, manipulate application data and functionality.

The severity depends on the nature of the actions the attacker induces.

---

## How CSRF Works

For a CSRF attack to occur, three conditions must be met:

1. **A Relevant Action**: An action within the application that the attacker wants to induce (e.g., changing email, password, permissions).

2. **Cookie-Based Session Handling**: The application relies solely on session cookies to authenticate requests.

3. **No Unpredictable Request Parameters**: The action's requests do not contain parameters that are hard to predict or guess by the attacker.

### Example Scenario

**Target Action: Changing Email Address**

**Legitimate Request:**
```plaintext
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Cookie: session=yvthwsztyeQkAPzeQ5gHgTvlyxHfsAfE

email=wiener@normal-user.com
```

**Conditions Met:**
- **Action Interest**: Changing the email can lead to account takeover.
- **Session Handling**: Relies on session cookies.
- **Predictable Parameters**: Attacker can guess the `email` parameter's structure.

**Attack Payload:**
```html
<html>
    <body>
        <form action="https://vulnerable-website.com/email/change" method="POST">
            <input type="hidden" name="email" value="pwned@evil-user.net" />
        </form>
        <script>
            document.forms[0].submit();
        </script>
    </body>
</html>
```

**Attack Flow:**
1. Victim visits the malicious page.
2. The form auto-submits, sending the request with the victim's session cookie.
3. The server processes the request, changing the victim's email.

---

## Constructing a CSRF Attack

**Using Tools like Burp Suite:**

1. **Capture a Legitimate Request**: Identify the request to be exploited.
2. **Generate CSRF PoC**: Use Burp Suite's Engagement tools to create a Proof of Concept.
3. **Deploy Malicious HTML**: Embed the generated HTML in a site controlled by the attacker.
4. **Induce Victim to Visit**: Share the malicious link via email, social media, etc.
5. **Execute Attack**: When the victim visits, the browser sends the trusted request, executing the attack.

---

## Common Defense Mechanisms Against CSRF

### 1. CSRF Tokens

**Description:**  
Unique, secret tokens generated by the server and embedded in client requests to verify legitimacy.

**Implementation Steps:**
1. **Generate Token**: Create a unique token per session.
2. **Store Token**: Save the token server-side (e.g., session storage).
3. **Embed Token**: Include the token in client-side requests (forms, AJAX).
4. **Validate Token**: On receiving a request, verify the token matches the stored one.

**Example:**

```html
<!-- Hidden Form Field -->
<form action="/email/change" method="POST">
    <input type="hidden" name="csrf_token" value="f7d3e9a2b5c8d1f4">
    <input type="email" name="email">
    <button type="submit">Change Email</button>
</form>
```

### 2. SameSite Cookies

**Description:**  
Attribute that controls whether cookies are sent with cross-site requests.

- **SameSite=Strict**: Cookies only sent in same-site requests.
- **SameSite=Lax**: Cookies sent with top-level navigation and safe HTTP methods.
- **SameSite=None**: Cookies sent in all contexts (requires Secure flag).

**Example:**

```plaintext
Set-Cookie: session_id=abc123; SameSite=Strict; Secure; HttpOnly
```

### 3. Referer-Based Validation

**Description:**  
Checks the `Referer` header to ensure the request originates from the trusted domain.

**Implementation Steps:**
1. **Inspect Referer Header**: Extract the `Referer` from the request.
2. **Validate Domain**: Ensure it matches the application's domain.
3. **Approve or Reject**: Proceed if valid; otherwise, reject.

**Example:**

```plaintext
Referer: https://example.com/account/settings
```

---

## Storing CSRF Tokens

While cookies are a common storage method, there are several alternatives. Below are detailed explanations and sample values for each.

### 1. Cookies

**Pros:**
- Automatically sent with every request.
- Easy to implement.

**Cons:**
- Accessible via JavaScript unless `HttpOnly` is set.
- Vulnerable to XSS if not properly secured.

**Double-Submit Cookie Pattern:**

- **Store Token in Cookie**: `Set-Cookie: csrf_token=d4e5f6g7h8i9j0; HttpOnly; Secure; SameSite=Strict`
- **Include Token in Request**: `X-CSRF-Token: d4e5f6g7h8i9j0` in headers or body.
- **Server Validation**: Compare cookie token with request token.

**Sample Values:**

```plaintext
Set-Cookie: csrf_token=w4y7m2n5b8v1q4p9; HttpOnly; Secure; SameSite=Strict
```

```plaintext
POST /api/update HTTP/1.1
Host: example.com
Content-Type: application/json
X-CSRF-Token: w4y7m2n5b8v1q4p9
Cookie: csrf_token=w4y7m2n5b8v1q4p9

{
    "product_id": "789",
    "quantity": 2
}
```

### 2. Hidden Form Fields

**Description:**  
Embed the CSRF token within the form as a hidden input field.

**Sample Values:**

```html
<form action="/update-password" method="POST">
    <input type="hidden" name="_token" value="p7y4m2k9v5b3q8n1">
    <input type="password" name="new_password">
    <button type="submit">Update Password</button>
</form>
```

**Submission Request:**

```plaintext
POST /update-password HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded

_token=p7y4m2k9v5b3q8n1&new_password=SecurePass123
```

### 3. HTML Meta Tags

**Description:**  
Include the CSRF token within a meta tag in the HTML `<head>`, accessible via JavaScript for AJAX requests.

**Sample Values:**

```html
<head>
    <meta name="csrf-token" content="8f4j2m9p6v3q7k1n8b5">
    <title>Account Settings</title>
</head>
```

**AJAX Request:**

```plaintext
POST /api/update-profile HTTP/1.1
Host: example.com
Content-Type: application/json
X-CSRF-Token: 8f4j2m9p6v3q7k1n8b5

{
    "name": "John Doe",
    "email": "john@example.com"
}
```

### 4. JavaScript Variables

**Description:**  
Expose the CSRF token through JavaScript variables for inclusion in dynamic requests.

**Sample Values:**

```html
<script>
    window.CSRF_TOKEN = "t5r8x2q4z7n9c6v3";
    // or
    const csrfToken = "t5r8x2q4z7n9c6v3";
</script>
```

**AJAX Request:**

```plaintext
POST /api/update HTTP/1.1
Host: example.com
Content-Type: application/json
X-CSRF-Token: t5r8x2q4z7n9c6v3

{
    "data": "update value"
}
```

### 5. Local Storage

**Description:**  
Store the CSRF token in the browser's Local Storage, accessible via JavaScript.

**Sample Values:**

```javascript
// Storing Token
localStorage.setItem('csrf_token', 'm3n6b9k2x5q8v1p7');
localStorage.setItem('token_expiry', '2024-01-20T15:30:00Z');
```

**AJAX Request:**

```plaintext
POST /api/data HTTP/1.1
Host: example.com
Content-Type: application/json
X-CSRF-Token: m3n6b9k2x5q8v1p7

{
    "action": "update",
    "value": "new data"
}
```

### 6. Session Storage

**Description:**  
Store the CSRF token in the browser's Session Storage, which is cleared when the tab is closed.

**Sample Values:**

```javascript
// Storing Token
sessionStorage.setItem('csrf_token', 'h7j4n1p8v5b2m9q6');
sessionStorage.setItem('issued_at', '2024-01-20T14:25:00Z');
```

**AJAX Request:**

```plaintext
POST /api/user/preferences HTTP/1.1
Host: example.com
Content-Type: application/json
X-CSRF-Token: h7j4n1p8v5b2m9q6

{
    "theme": "dark",
    "language": "en"
}
```

### 7. Data Attributes

**Description:**  
Embed the CSRF token within HTML elements using `data-` attributes.

**Sample Values:**

```html
<div id="app" 
     data-csrf="k2m5p8v3n6b9x4q7" 
     data-csrf-expiry="2024-01-20T16:00:00Z">
    <!-- application content -->
</div>
```

**AJAX Request:**

```plaintext
POST /api/comments HTTP/1.1
Host: example.com
Content-Type: application/json
X-CSRF-Token: k2m5p8v3n6b9x4q7

{
    "comment": "Great article!",
    "post_id": "123"
}
```

### 8. URL Parameters (Not Recommended)

**Description:**  
Append the CSRF token as a query parameter in URLs. This method exposes the token in browser history, logs, and referer headers, making it less secure.

**Sample Values:**

```html
<a href="/api/download?csrf_token=f3h6k9m2p5v8n1b4">Download File</a>
```

**Request URL:**

```plaintext
GET /api/download?csrf_token=f3h6k9m2p5v8n1b4 HTTP/1.1
Host: example.com
```

---

## Sample Request/Response Cycles

### 1. Using Request Headers and Body Data

**Scenario:** Changing a User's Email Address

#### a. Initial Page Load Request

**Request Headers:**
```plaintext
GET /account/settings HTTP/1.1
Host: example.com
Cookie: session_id=abc123def456
Accept: text/html
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0
```

**Server Response Headers:**
```plaintext
HTTP/1.1 200 OK
Content-Type: text/html
Set-Cookie: csrf_token=f7d3e9a2b5c8d1f4; HttpOnly; Secure; SameSite=Strict
```

**Response Body (HTML):**
```html
<form action="/email/change" method="POST">
    <input type="hidden" name="csrf_token" value="f7d3e9a2b5c8d1f4">
    <input type="email" name="email" placeholder="New Email">
    <button type="submit">Change Email</button>
</form>
```

#### b. Standard Form Submission

**Request Headers:**
```plaintext
POST /email/change HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded
Cookie: session_id=abc123def456; csrf_token=f7d3e9a2b5c8d1f4
```

**Request Body:**
```plaintext
csrf_token=f7d3e9a2b5c8d1f4&email=new.email@example.com
```

**Server Validation:**
1. Extract `csrf_token` from cookies: `f7d3e9a2b5c8d1f4`
2. Extract `csrf_token` from form data: `f7d3e9a2b5c8d1f4`
3. Compare tokens: Match.
4. Validate and update the email.

**Success Response:**
```plaintext
HTTP/1.1 200 OK
Content-Type: application/json
Set-Cookie: csrf_token=k9m2p4n8v6b3q7t1; HttpOnly; Secure; SameSite=Strict
```

**Response Body:**
```json
{
    "status": "success",
    "message": "Email updated successfully"
}
```

#### c. JSON AJAX Request

**Request Headers:**
```plaintext
POST /email/change HTTP/1.1
Host: example.com
Content-Type: application/json
X-CSRF-Token: f7d3e9a2b5c8d1f4
Cookie: session_id=abc123def456; csrf_token=f7d3e9a2b5c8d1f4
```

**Request Body:**
```json
{
    "email": "new.email@example.com"
}
```

**Server Validation:**
1. Extract `csrf_token` from cookies: `f7d3e9a2b5c8d1f4`
2. Extract `X-CSRF-Token` from headers: `f7d3e9a2b5c8d1f4`
3. Compare tokens: Match.
4. Validate and update the email.

**Success Response:**
```plaintext
HTTP/1.1 200 OK
Content-Type: application/json
Set-Cookie: csrf_token=k9m2p4n8v6b3q7t1; HttpOnly; Secure; SameSite=Strict
```

**Response Body:**
```json
{
    "status": "success",
    "message": "Email updated successfully"
}
```

### 2. Other Common Storage Methods

#### 1. Token Rotation After Login

**Login Request:**
```plaintext
POST /login HTTP/1.1
Content-Type: application/json

{
    "username": "user@example.com",
    "password": "securepass123"
}
```

**Login Response Headers:**
```plaintext
HTTP/1.1 200 OK
Set-Cookie: session_id=xyz789qrs456; HttpOnly; Secure; SameSite=Lax
Set-Cookie: csrf_token=m1n2b3v4c5x6z7; HttpOnly; Secure; SameSite=Strict
```

#### 2. Token Refresh After Expiry

**Expired Token Request:**
```plaintext
POST /api/data HTTP/1.1
X-CSRF-Token: h8j9k0l1m2n3p4 (expired)
Cookie: csrf_token=h8j9k0l1m2n3p4
```

**Server Response with New Token:**
```plaintext
HTTP/1.1 401 Unauthorized
Content-Type: application/json
Set-Cookie: csrf_token=q7w8e9r0t1y2u3; HttpOnly; Secure; SameSite=Strict

{
    "status": "error",
    "message": "Token expired, new token issued"
}
```

#### 3. Double Submit Cookie Pattern

**Request:**
```plaintext
POST /api/update HTTP/1.1
Host: example.com
Content-Type: application/json
X-CSRF-Token: d4e5f6g7h8i9j0
Cookie: csrf_token=d4e5f6g7h8i9j0

{
    "data": "update_value"
}
```

---

## Best Practices for CSRF Token Management

1. **Use Secure Token Generation Methods:**
   - Utilize cryptographically secure functions (e.g., `secrets.token_hex` in Python).

2. **Store Tokens Server-Side Securely:**
   - Keep tokens within secure session storage or databases.
   - Avoid exposing tokens in URLs or logs.

3. **Embed Tokens in All State-Changing Requests:**
   - Ensure that every form or AJAX request that modifies state includes the CSRF token.

4. **Implement Token Expiration:**
   - Set tokens to expire after a reasonable period (e.g., 1 hour).
   - Regenerate tokens upon sensitive actions or at regular intervals.

5. **Validate Tokens Strictly:**
   - Compare tokens using constant-time comparison functions to prevent timing attacks.
   - Ensure tokens match between storage and request.

6. **Combine Multiple Defense Mechanisms:**
   - Use CSRF tokens alongside SameSite cookies and proper authentication.
   - Implement Content Security Policy (CSP) to mitigate XSS risks.

7. **Handle Token Errors Gracefully:**
   - Inform users appropriately if their session has expired or if a token is invalid.
   - Provide mechanisms to refresh or regenerate tokens as needed.

8. **Protect Against XSS:**
   - Implement strong input validation and output encoding.
   - Use security headers like `Content-Security-Policy` to reduce XSS vulnerabilities.

9. **Regularly Rotate CSRF Tokens:**
   - Refresh tokens periodically to minimize the window for potential exploitation.

10. **Avoid Storing Tokens in Insecure Locations:**
    - Prefer methods like hidden form fields or JavaScript variables over URL parameters.


---

## Additional Resources

- [OWASP CSRF Prevention Cheat Sheet](https://owasp.org/www-project-cheat-sheets/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)
- [Flask-WTF CSRF Protection](https://flask-wtf.readthedocs.io/en/stable/csrf.html)
- [SameSite Cookies Explained](https://web.dev/samesite-cookies-explained/)
- [Understanding CSRF](https://developer.mozilla.org/en-US/docs/Glossary/CSRF)
- [Content Security Policy (CSP)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)