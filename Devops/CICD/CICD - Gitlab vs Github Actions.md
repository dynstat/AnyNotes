# Introduction to GitHub Actions

GitHub Actions is a powerful CI/CD platform integrated directly into GitHub. It allows you to automate, customize, and execute your software development workflows right in your repository. With GitHub Actions, you can build, test, and deploy your code directly from GitHub.

# GitHub Actions vs. GitLab CI/CD

Understanding the similarities and differences between GitHub Actions and GitLab CI/CD can help you transition smoothly. Here's a comparison of key features:

| **Feature**               | **GitLab CI/CD**                              | **GitHub Actions**                               |
|---------------------------|------------------------------------------------|---------------------------------------------------|
| **Configuration File**    | `.gitlab-ci.yml`                                | `.github/workflows/*.yml`                         |
| **Pipelines / Workflows** | Pipeline                                         | Workflow                                           |
| **Stages**                | Stages (e.g., build, test, deploy)              | Jobs (can be organized logically)                 |
| **Jobs**                  | Jobs within stages                               | Jobs within workflows                              |
| **Steps**                 | Scripted steps within jobs                       | Steps within jobs, using actions                   |
| **Artifacts**             | `artifacts` keyword to store build outputs      | `actions/upload-artifact` and `actions/download-artifact` |
| **Runners**               | GitLab Runners                                    | GitHub Runners                                     |
| **Cache**                 | Caching dependencies across jobs                 | `actions/cache` for caching dependencies           |
| **Environments**          | Environments for deployments                     | Environments with approval workflows              |
| **Automated Releases**    | Using GitLab API                                  | Using GitHub API and actions like `create-release` |

# Key Features of GitHub Actions

## Workflows

Workflows are automated processes that you set up in your GitHub repository. They are defined by YAML files stored in the `.github/workflows/` directory.

```yaml: .github/workflows/ci.yml
name: CI Pipeline

on:
  push:
    branches:
      - main
  pull_request:

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '14'

      - name: Install dependencies
        run: npm install

      - name: Run tests
        run: npm test
```

## Jobs and Steps

- **Jobs**: A job is a set of steps that execute on the same runner.
- **Steps**: Individual tasks within a job. Steps can run commands or use actions.

```yaml: .github/workflows/deploy.yml
name: Deploy

on:
  push:
    tags:
      - 'v*.*.*'

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Deploy to Production
        run: |
          echo "Deploying to production..."
          # Deployment commands here
```

## Actions

Actions are reusable units of code that can be shared and used across workflows. GitHub provides a marketplace for actions, or you can create your own.

```yaml
- name: Checkout code
  uses: actions/checkout@v3
```

## Artifacts

Artifacts are files generated by your workflow that you want to save. They can be used later in the workflow or downloaded.

```yaml: .github/workflows/artifact.yml
name: Build and Store Artifact

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Build project
        run: |
          echo "Building project..."
          mkdir -p build
          echo "Build output" > build/output.txt

      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: build-output
          path: build/output.txt
```

## Caching

Caching dependencies can speed up your workflows by reusing previously installed dependencies.

```yaml
- name: Cache Node.js modules
  uses: actions/cache@v3
  with:
    path: ~/.npm
    key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
    restore-keys: |
      ${{ runner.os }}-node-
```

## Secrets

Secrets allow you to store sensitive information, such as API keys, securely. They can be accessed in workflows using `${{ secrets.SECRET_NAME }}`.

```yaml
- name: Deploy to Server
  run: ssh user@server "deploy.sh"
  env:
    SSH_KEY: ${{ secrets.SSH_KEY }}
```

## Matrix Builds

Matrix builds allow you to run multiple variations of a job, such as testing against multiple Node.js versions.

```yaml: .github/workflows/matrix.yml
name: Matrix Build

on:
  push:
    branches:
      - main

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [12, 14, 16]

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}

      - name: Install dependencies
        run: npm install

      - name: Run tests
        run: npm test
```

# Practical Use Cases

## Continuous Integration (CI) Pipeline

Automate the build and test process on every push or pull request.

```yaml: .github/workflows/ci.yml
name: CI Pipeline

on:
  push:
    branches:
      - main
  pull_request:

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3  # Checks out the repository

      - name: Set up Node.js
        uses: actions/setup-node@v3  # Sets up Node.js environment
        with:
          node-version: '14'  # Specifies Node.js version

      - name: Install dependencies
        run: npm install  # Installs project dependencies

      - name: Run tests
        run: npm test  # Executes test scripts
```

### Explanation

1. **Trigger Events**: The workflow triggers on pushes to the `main` branch and on pull requests.
2. **Job Definition**: Defines a job named `build` that runs on `ubuntu-latest` runner.
3. **Steps**:
   - **Checkout Code**: Uses the `actions/checkout` action to clone the repository.
   - **Set up Node.js**: Sets up the Node.js environment with the specified version.
   - **Install Dependencies**: Runs `npm install` to install project dependencies.
   - **Run Tests**: Executes the test suite with `npm test`.

## Automated Releases Using GitHub API

Automate the creation of releases when a new tag is pushed.

```yaml: .github/workflows/release.yml
name: Release

on:
  push:
    tags:
      - 'v*.*.*'  # Triggers on version tags like v1.0.0

jobs:
  release:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ github.ref }}
          draft: false
          prerelease: false

      - name: Upload Release Asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./build/output.txt
          asset_name: output.txt
          asset_content_type: text/plain
```

### Explanation

1. **Trigger Event**: The workflow triggers when a tag matching `v*.*.*` is pushed.
2. **Job Definition**: Defines a job named `release` that runs on `ubuntu-latest`.
3. **Steps**:
   - **Checkout Code**: Clones the repository.
   - **Create Release**: Uses `actions/create-release` to create a new release based on the pushed tag.
   - **Upload Release Asset**: Attaches artifacts (e.g., build outputs) to the created release using `actions/upload-release-asset`.

## Deploying to a Cloud Provider (e.g., AWS)

Deploy your application to AWS when changes are pushed to the `main` branch.

```yaml: .github/workflows/deploy-aws.yml
name: Deploy to AWS

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Deploy to S3
        run: |
          aws s3 sync ./build s3://my-bucket-name --delete
```

### Explanation

1. **Trigger Event**: The workflow triggers on pushes to the `main` branch.
2. **Job Definition**: Defines a job named `deploy` that runs on `ubuntu-latest`.
3. **Steps**:
   - **Checkout Code**: Clones the repository.
   - **Configure AWS Credentials**: Uses `aws-actions/configure-aws-credentials` to set up AWS credentials from secrets.
   - **Deploy to S3**: Runs an AWS CLI command to sync the `./build` directory with an S3 bucket.

# Similarities Between GitLab and GitHub Terminologies

| **GitLab CI/CD** | **GitHub Actions**          |
|------------------|-----------------------------|
| `.gitlab-ci.yml` | `.github/workflows/*.yml`   |
| Pipeline         | Workflow                     |
| Stage            | Job (can represent stages)   |
| Job              | Job                           |
| Script           | Step using `run` or an action |
| Artifacts        | Artifacts via `upload-artifact` and `download-artifact` |
| Cache            | `actions/cache`               |
| Variables        | Secrets and environment variables |
| Runners          | Runners                        |

# Conclusion

GitHub Actions offers a flexible and integrated CI/CD solution within GitHub. By understanding its features and how they map to GitLab CI/CD, you can efficiently set up and manage your workflows. The provided YAML examples demonstrate common use cases, making it easier to transition and leverage GitHub Actions for your projects.

# Additional Resources

- [GitHub Actions Documentation](https://docs.github.com/en/actions)
- [GitHub Actions Marketplace](https://github.com/marketplace?type=actions)
- [Comparing GitHub Actions and GitLab CI/CD](https://docs.gitlab.com/ee/ci/github_actions_comparison.html)

# Further Examples

## Reusable Workflows

GitHub Actions allows you to create reusable workflows that can be called from other workflows.

```yaml: .github/workflows/reusable.yml
name: Reusable Workflow

on:
  workflow_call:
    inputs:
      name:
        required: true
        type: string

jobs:
  greet:
    runs-on: ubuntu-latest

    steps:
      - name: Greet
        run: echo "Hello, ${{ inputs.name }}!"
```

```yaml: .github/workflows/caller.yml
name: Caller Workflow

on:
  push:
    branches:
      - main

jobs:
  call-reusable:
    uses: ./.github/workflows/reusable.yml
    with:
      name: GitHub Actions
```

### Explanation

1. **Reusable Workflow (`reusable.yml`)**:
   - **Trigger**: Defined with `workflow_call` to be reusable.
   - **Inputs**: Accepts a `name` input.
   - **Job**: Contains a job that greets the provided name.

2. **Caller Workflow (`caller.yml`)**:
   - **Trigger**: Runs on pushes to the `main` branch.
   - **Job**: Calls the reusable workflow and passes the `name` input.

## Environment Protection Rules

GitHub Actions allows you to define environments with protection rules, such as requiring manual approvals before deployment.

```yaml: .github/workflows/protected-deploy.yml
name: Protected Deploy

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://prod.example.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Deploy to Production
        run: |
          echo "Deploying to production..."
          # Deployment commands here
```

### Explanation

1. **Environment**: Specifies the `production` environment. You can set protection rules in the repository settings.
2. **Deploy Job**: Deployment steps are executed after environment approvals, if configured.

# Tips for Migrating from GitLab CI/CD to GitHub Actions

1. **Map Pipeline to Workflows**: Each GitLab pipeline can correspond to one or more GitHub workflows.
2. **Convert `.gitlab-ci.yml` to `.github/workflows/*.yml`**: Translate stages and jobs appropriately.
3. **Use GitHub Actions Marketplace**: Leverage pre-built actions to replace GitLab features.
4. **Secure Secrets**: Transfer your GitLab CI/CD variables to GitHub Secrets.
5. **Test Incrementally**: Start by replicating simple pipelines and progressively add complexity.

# Summary

GitHub Actions provides a robust and flexible platform for automating your CI/CD pipelines, similar to GitLab CI/CD. By understanding the core concepts, workflows, and how to leverage its features with practical examples, you can effectively manage your project's automation needs within GitHub.

---

# Managing Multiple YAML Files in GitHub Actions vs. GitLab CI/CD

When transitioning from GitLab CI/CD to GitHub Actions, understanding how to organize pipeline configurations is crucial. This guide explores whether to use a single YAML configuration file or multiple files in both GitHub Actions and GitLab CI/CD, followed by best practices for each.

## Multiple vs. Single YAML Files

### GitLab CI/CD

In GitLab, it's common to have a single `.gitlab-ci.yml` file per repository that defines all pipelines for various branches and stages.

```yaml: .gitlab-ci.yml
stages:
  - build
  - test
  - deploy

build_job:
  stage: build
  script:
    - echo "Building the project..."

test_job:
  stage: test
  script:
    - echo "Running tests..."

deploy_job:
  stage: deploy
  script:
    - echo "Deploying the project..."
```

### GitHub Actions

GitHub Actions allows for multiple workflow YAML files within the `.github/workflows/` directory. This enables separating different workflows based on triggers, purposes, or other criteria.

```yaml: .github/workflows/ci.yml
name: CI Pipeline

on:
  push:
    branches:
      - main
  pull_request:

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '14'

      - name: Install dependencies
        run: npm install

      - name: Run tests
        run: npm test
```

```yaml: .github/workflows/deploy.yml
name: Deploy Pipeline

on:
  push:
    tags:
      - 'v*.*.*'

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Deploy to Production
        run: |
          echo "Deploying to production..."
          # Deployment commands here
```

## Best Practices for YAML Pipeline Files

### GitLab CI/CD Best Practices

1. **Single Configuration File**: Maintain all pipeline configurations within a single `.gitlab-ci.yml` file for consistency and ease of management.
2. **Stages and Jobs**: Clearly define stages (e.g., build, test, deploy) and associate jobs with appropriate stages.
3. **Use Includes**: Modularize the pipeline by including external YAML files to manage complex pipelines.
   ```yaml: .gitlab-ci.yml
   include:
     - local: '/ci-templates/build.yml'
     - local: '/ci-templates/test.yml'
     - local: '/ci-templates/deploy.yml'
   ```
4. **Leverage Variables**: Use predefined and custom variables to manage environment-specific configurations.
5. **Cache Dependencies**: Utilize caching to speed up pipeline execution.
   ```yaml
   cache:
     paths:
       - node_modules/
   ```
6. **Artifacts Management**: Define artifacts to pass data between jobs.
   ```yaml
   artifacts:
     paths:
       - build/
     expire_in: 1 week
   ```
7. **Environment-specific Pipelines**: Use `only` and `except` keywords to control when jobs run.
   ```yaml
   deploy_production:
     stage: deploy
     script:
       - echo "Deploying to production..."
     only:
       - main
   ```

### GitHub Actions Best Practices

1. **Multiple Workflow Files**: Organize workflows into separate YAML files based on their function (e.g., CI, CD, tests).
2. **Descriptive Naming**: Name workflows clearly to indicate their purpose.
3. **Reusable Actions**: Utilize reusable actions from the [GitHub Marketplace](https://github.com/marketplace?type=actions) or create custom actions for common tasks.
4. **Secrets Management**: Store sensitive information using GitHub Secrets and reference them securely.
   ```yaml
   - name: Deploy to Server
     run: ssh user@server "deploy.sh"
     env:
       SSH_KEY: ${{ secrets.SSH_KEY }}
   ```
5. **Matrix Strategies**: Use matrix builds to test across multiple environments or configurations.
   ```yaml
   strategy:
     matrix:
       node-version: [12, 14, 16]
   ```
6. **Caching Dependencies**: Implement caching to reduce workflow execution time.
   ```yaml
   - name: Cache Node.js modules
     uses: actions/cache@v3
     with:
       path: ~/.npm
       key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
       restore-keys: |
         ${{ runner.os }}-node-
   ```
7. **Environment Protection Rules**: Define environments with protection rules, such as manual approvals for deployments.
   ```yaml
   environment:
     name: production
     url: https://prod.example.com
   ```
8. **Use Templates and Reusables**: Leverage reusable workflows to avoid duplication.
   ```yaml
   uses: ./.github/workflows/reusable.yml
   with:
     name: GitHub Actions
   ```

## Summary of Best Practices

| **Aspect**               | **GitLab CI/CD**                               | **GitHub Actions**                                  |
|--------------------------|-------------------------------------------------|------------------------------------------------------|
| **Configuration Files** | Single `.gitlab-ci.yml` per repository          | Multiple `.github/workflows/*.yml` files allowed     |
| **Stages/Jobs**         | Define stages and associate jobs accordingly     | Use jobs within workflows; organize by purpose       |
| **Modularization**      | Use `include` to split configurations            | Use reusable workflows and composite actions          |
| **Caching**             | Utilize `cache` keyword                           | Use `actions/cache` action                            |
| **Artifacts**           | Define artifacts in `.gitlab-ci.yml`             | Use `actions/upload-artifact` and `actions/download-artifact` actions |
| **Secrets Management**  | Use CI/CD variables                               | Use GitHub Secrets                                    |
| **Environment Management** | Define environments with deployment rules      | Use environments with protection rules               |
| **Reusability**         | Include external YAML templates                   | Create and use reusable workflows and marketplace actions |

## Conclusion

Both GitLab CI/CD and GitHub Actions offer robust solutions for automating your development workflows. While GitLab typically relies on a single `.gitlab-ci.yml` file, GitHub Actions provides the flexibility to use multiple workflow files, allowing for better organization and separation of concerns. Adhering to best practices in structure, modularity, and security will ensure efficient and maintainable pipelines in both platforms.